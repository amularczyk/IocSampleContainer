\{document}
Cześć. Nazywa się Adrian Mularczyk i dzisiaj opowiem wam co to jest wstrzykiwanie zależności, jak dodać je do projektu i jak wygląda jego przykładowa implemetacja.


\{Agenda}
Tutaj krótka agenda. Najpierw opiszę jaki problem wstrzykiwanie zależności rozwiązuje. Potem w kilku zdaniach opowiem czym ono jest, a następnie przejdziemy do kodu. Pokaże jak dodać wstrzykiwanie zależności do projektu webowego w zwykłym .NET, a także w .NET Core. Dalej zaprezentuję prostą implementację wstrzykiwania zależności. Na koniec opowiem jak może taką implementację rozbudować.


\{Przedstawienie problemu}
Na przestrzeni lat powstało bardzo dużo projektów. Część z nich była łatwiejsza w utrzymaniu, część trudniejsza. Analiza tych projektów pozwoliła zauważyć, że są pewne zasady, które powodują, że projekty rozwija się łatwiej. Te zasady zostały połączone w zbiory zasad.

\{SOLID}
Najbardziej popularnych i powszechnie stosowanym zbiorem zasad jest SOLID. Składa się on z pięciu zasady: Single responsibility principle, open/close principle, liskov substituion principle, interface segregation principle oraz dependency inversion principle.

\{SOLID2}
Niniejsza prezentacja w dużej mierze skupia się na rozwiązaniu ostatniej z tych zasad.

\{Dependency Inversion Principal}
Dependency Inversion Principal mówi o tym, że wysokopoziomowe moduły nie powinny zależeć od modułów niskopoziomowych. Zależności między nimi powinny wynikać z abstrakcji.
<Opis kodu>

\{Kontenery wstrzykiwania zależności}
Aby łatwiej zastosować przedstawioną zasadę można wesprzeć się tzw. kontenerem wstrzykiwania zależności.
Taki kontener jest obiektem, który przechowuje mapę, w której abstrakcje (interfejsy, klasy abstrakcyjne) mają przyporządkowane implementacje, czyli klasy implementujące interfejsy lub dziedziczące z klas abstrakcyjnych.
Kontenery dostarczają nam kilku funkcjonalności.
Jedną z nich jest możliwość zdefiniowania tego instancję jakiej klasy należy zwrócić w miejsce konkretnego typu, czyli rejestracja - metoda Register.
Drugą jest tworzenie instancji obiektów konkretnej klasy lub implementujących określony interfejs - metoda Resolve.
<Opis kodu>


\{Wstrzykiwanie zależności}
Wspomniałem o wstrzykiwaniu zależności, ale czym ono jest? Jest to techniką, która umożliwia luźne powiązania, a luźne powiązania sprawiają, że kod jest rozszerzalny i łatwy w utrzymaniu.

\{Rodzaje wstrzykiwania zależności}
Wstrzykiwanie zależności może odbywać się na 3 sposoby:
Wstrzykiwanie przez konstruktor, przez metodę oraz przez właściwość.
<Opis kodu>

\{Registration types}
Najbardziej popularnymi rodzajami rejestracji są:
- Zarejestruj jako Singleton, czyli zwracamy zawszę tą samą instancję.
- Zarejestruj jako Transient, czyli zawsze zwracamy nową instancję.
- Zarejestruj jako Scoped (można spotkać również jako wątek albo HttpRequest), czyli dla danego zakresu zwróć tą samą instancję, ale dla dwóch różnych zakresów zwróć różne instancje.
- Zarejestruj jako funckję - to odnośni się do trzech powyższych rejestracji, ponieważ funkcja jest przekazywana jako parametr.

\{Implementacje przemysłowe}
Na rynku jest wiele implementacji wstrzykiwania zależności. Poniżej przedstawiono kilka najbardziej popularnych (według ilości pobrań z NuGet) oraz kilka najszybszych (według rankingu na blogu Daniela Palme).


\{Code}
\{Dodanie DI do własnego projektu}
A teraz będzie trochę kodu. Na początek pokażę jak dodać wstrzykiwanie zależności w projekcie .NET Core, a potem to samo dla projektu w zwykłym .NET Framework z wykorzystaniem Autofac.

\{Implementacja}
Zobaczyliśmy jak dodać wstrzykiwanie zależności do naszego projektu. Ale co się kryje w środku?
1. SimpleContainer
2. Singletons
3. Interfaces
4. RegisterionKind
5. Scopes

\{Rozszerzenia}
A teraz kilka przykładów jak taką implementację można by rozszerzyć:
1. Lista zamiast słownika.
Do klasy RegisteredType wystarczy dodać InputType. Rejestracja wygląda niemal identycznie, a w Resolve zamiast w słowniku pobrać element według danego klucza, to przeszukujemy listę.
2. Rejestracja wielu typów wejściowych.
W niektórych implementacjach istnieje możliwość zarejestrowania wielu typów na jeden - taka sytuacja może być porządana gdy jakaś nasza klasa implementuje wiele interfejsów. Co musimy zrobić, to w naszym słowniku zamienić klucz który jest Typem, na listę typów. W rejestracji teraz musimy patrzeć, czy dany typ docelowy został już zarejestrowany i jeśli tak, to typ wejściowy dodać do listy kluczy, a jeśli nie, to stworzyć nową parę: lista kluczy i zarejestrowany typ. Resolve wygląda podobnie, tylko teraz przeszukujemy listę klucz w poszukiwaniu naszego typu.
3. Rejestracja wielu typów docelowych.
To przyda nam się, gdy wiele klas implementuje ten sam interfejs. Można sobie z tym radzić tworzać dodatkowe interfejsy, a możne także skorzystać z czegoś takiego jak 'name parameter'. Klucz naszego słownika nie ulega zmianie, ale zmianie ulega wartość. Teraz zamiast RegisteredType będziemy mieli słownik par: nazwa i RegisteredType. Zatem w operacji Register patrzymy, czy nasz typ wejściowy już jest w słowniku i jeśli tak, to parę nazwa i RegisteredType dodajemy do jego słownika, a jeśli nie, to tworzymy nową parę zawierającą typ wejściowy i słownik. Resolve zamiast przeglądać jeden słownik, to teraz przegląda dwa - najpierw aby dla danego typu, a następnie dla danej nazwy.

\section{Podsumowanie}
Mam nadzieję, że dzięki tej prezentacji dowiedzieliście się trochę więcej o wstrzykiwaniu zależności, a także przekonaliście się, że tak na prawdę nie dzieję się tam żadna magia i chętniej będziecie używać tego w swoich projektach.
Czy są jakieś pytania?
Z racji, że była to moja pierwsza prezetnacja w życiu, to byłbym wdzięczny za feedback. Może być osobiście, może być na e-mail. Jakby ktoś się wahał, to nie obawiam się krytyki.
Dziękuję.